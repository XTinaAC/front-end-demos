<html> iterators & generators </html>
<script>
/*ï¼ˆè¿­ä»£å™¨ï¼‰ã€Iteratorsã€‘are objects with a specific interface designed
    for iteration. Theã€next()ã€‘method of iterators return an object: { 
        value: éå†å€¼
        done: æ˜¯å¦ç»“æŸ
}*/

/*ï¼ˆç”Ÿæˆå™¨ï¼‰ã€Generatorsã€‘can be:
    1) function declarations
    2) function expressions
    3) object methods (ES5 object literal; ES6 method shorthand)
*/
function *generator1() {}
const generator2 = function *() {}
const obj = {
    generator3: function *() {},
    *generator4() {}
}

/*ï¼ˆå¯è¿­ä»£ç›®æ ‡ï¼‰ã€Iterablesã€‘are objects with aã€Symbol.iteratorã€‘property, which
    specifies a function that returns anã€iteratorã€‘for the given object,
    and are designed to be used with theã€for-ofã€‘loop.
        1) in ES6, all collection objectsï¼ˆarrays/sets/mapsï¼‰and strings 
            areã€iterablesã€‘, and they have a defaultã€iteratorã€‘specified
        2) allã€iteratorsã€‘created byã€generatorsã€‘are alsoã€iterablesã€‘, 
            andã€generatorsã€‘assign theã€Symbol.iteratorã€‘property by default.
*/
const iterator1 = generator1();
const iterator2 = generator2();
const iterator3 = obj.generator3();
const iterator4 = obj.generator4();
console.log(
    "---iterables---\n",
    iterator1[Symbol.iterator], iterator1.next(), " (1)\n",
    iterator2[Symbol.iterator], iterator2.next(), " (2)\n",
    iterator3[Symbol.iterator], iterator3.next(), " (3)\n",
    iterator4[Symbol.iterator], iterator4.next(), " (4)\n",
    [][Symbol.iterator], [1,2,3].values().next(),                               " (5)\n",
    new Set()[Symbol.iterator], new Set([1,2,3]).values().next(),               " (6)\n",
    new Map()[Symbol.iterator], new Map([['A', 1], ['B', 2]]).entries().next(), " (7)\n",
    ''[Symbol.iterator], 'ABC'[Symbol.iterator]().next(),                       " (8)\n",
)
/* ------ for(let num of arr) {} ------
    We useã€for-ofã€‘loops onã€iterablesã€‘,
    which has aã€Symbol.iteratorã€‘property,
    which when called by the JS engine, returns anã€iteratorã€‘,
    of which theã€next()ã€‘method is called, and returns aã€result objectã€‘
    whoseã€valueã€‘is read intoã€numã€‘whenã€done == falseã€‘
    and the loop exits whenã€done == trueã€‘, andã€numã€‘is never
        assigned the value ofã€undefinedã€‘
*/

/*
    The for-of statement will throw an error when you use it on 
        a non-iterable object, null, or undefined.
    Developer-defined objects are notã€iterableã€‘by default, 
        but you can make them iterable by creating aã€Symbol.iteratorã€‘
        property containing aã€generatorã€‘.
*/
const iterate_obj = {
    items: [
        { key: 'a', value: 1 },
        { key: 'b', value: 2 },
        { key: 'c', value: 3 }
    ],
    *[Symbol.iterator](){
        for(let item of this.items) {
            yield item;
        }
    }
};
for(let { key, value } of iterate_obj) {
    console.log("{key}, {value}: ", key, value);
}
/*
    Becauseã€Symbol.iteratorã€‘specifies the defaultã€iteratorã€‘, we can use it
      to detect whether an object isã€iterableã€‘.
    Theã€for-ofã€‘loop does a similar check before executing.
*/
function isIterable(object) {
    return typeof object[Symbol.iterator] === 'function';
}
console.log(`is Iterable or Not: \n
    array: ${isIterable([1,2,3])} \n
    string: ${isIterable("123")} \n
    map: ${isIterable(new Map())} \n
    set: ${isIterable(new Set())} \n
    weakMap: ${isIterable(new WeakMap())} \n
    weakSet: ${isIterable(new WeakSet())} \n
`);

/*
    Collection Iteratorsï¼ˆfor arraysã€mapsã€setsï¼‰:
        entries()   <=>   [key, value]
        values()
        keys()
    Forã€arraysã€‘, the 1st item is the numeric index;
    Forã€setsã€‘, the 1st item is also the value (it doubles as a key);
    Forã€mapsã€‘, the 1st item is the key.
        arr::: [0, 'black']
        arr::: [1, 'white']
        set::: ['black', 'black']
        set::: ['white', 'white']
        map::: ['black', '#000']
        map::: ['white', '#fff']
*/
const color_arr = ['black', 'white'];   color_arr.ABCDEF='FEDCBA';
const color_set = new Set(color_arr);
const color_map = new Map();
color_map.set('black', '#000');
color_map.set('white', '#fff');
for(let item of color_arr.entries()) { console.log("arr:::", item) }
for(let item of color_arr.keys()) { console.log("arr-KEY:::", item) }
for(let item of color_arr.values()) { console.log("arr-VAL:::", item) }

for(let item of color_set.entries()) { console.log("set:::", item) }
for(let item of color_set.keys()) { console.log("set-KEY:::", item) }
for(let item of color_set.values()) { console.log("set-VAL:::", item) }

for(let item of color_map.entries()) { console.log("map:::", item) }
for(let item of color_map.keys()) { console.log("map-KEY:::", item) }
for(let item of color_map.values()) { console.log("map-VAL:::", item) }
/*
    Each collection type also has a default iterator that is used byã€for-ofã€‘
    whenever an iterator isnâ€™t explicitly specified. 
        Forã€arraysã€‘andã€setsã€‘ï¼švalues() is the default iterator
        Forã€mapsã€‘ï¼šentries() is the default iterator
            ï¼ˆwhich return the same array format that 
                can be passed into the Map constructor,
                    a format easy for destructuring inã€for-ofã€‘as belowï¼‰
*/
for(let item of color_arr) { console.log(":::ARR:::", item) }
for(let item of color_set) { console.log(":::SET:::", item) }
for(let [key, value] of color_map) { console.log(":::MAP:::", key, value) }
/*
    ã€for-ofã€‘loop iterates over only numeric indexes;
    ã€for-inã€‘loop iterates overã€propertiesã€‘rather than just the numeric indexes.
*/
for(let item in color_arr) { console.log("for-in:::ARR:::", item) } // å¤šäº†FEDCBAçš„æ‰“å°
/*
    ES5 formalized bracket notation str[0] for accessing characters in string,
    but it works onã€code unitsã€‘rather thanã€charactersã€‘, so it can NOT be used
    to accessã€multiple-byteã€‘characters correctly.

    But the defaultã€iteratorã€‘for strings works onã€charactersã€‘rather thanã€code unitsã€‘ï¼Œ
        which is more in line with what you'd expect.

    âš  JavaScriptåªæ”¯æŒUTF-16ç¼–ç ï¼ˆå•ä¸ªå­—ç¬¦çš„code unité•¿åº¦ä¸º: 2 æˆ– 4 å­—èŠ‚ï¼‰
    âš  ä¸­æ–‡å­—ç¬¦çš„ç¼–ç ï¼š
        UTF-8ï¼š ã€ 1 character ã€‘ã€ 3 code units ã€‘ã€ 3 bytes ã€‘
        UTF-16ï¼šã€ 1 character ã€‘ã€ 1 code unit ã€‘ã€ 2 bytes ã€‘
*/
const msg = "Ağ ®·ğŸ˜Šå‰B";
console.log(`length of ${msg} is: `, msg.length);    // 7ï¼ˆ1-2-2-1-1ï¼‰
for(let idx=0; idx<msg.length; idx++) { console.log(`code unit: ${msg[idx]}`)}  // Aå‰B
for(let c of msg) { console.log(`character: ${c}`)}  // Ağ ®·ğŸ˜Šå‰B

/*
    ã€NodeListã€‘default iterators are added in ES6:
*/
const li_nodes = document.getElementsByTagName("li");
for(let div of li_nodes) {
    console.log(div.nodeType);
    console.log(div.innerHTML);
    console.log(div.textContent);
}
/*
    Theã€spread operatorã€‘æ‰©å±•è¿ç®—ç¬¦ works on allã€iterablesã€‘
        & uses theã€default iteratorã€‘to determine which values to include.
*/
let map1 = new Map([['A', 1], ['B', 2], ['C', 3]]),
    arr1 = [...map1],
    set1 = new Set([111, 222, 333]),
    arr2 = [...set1],
    str1 = 'XTINA',
    arr3 = [...str1],
    arr4 = [...li_nodes]
console.log(...arr1);
console.log(...arr2);
console.log(...arr3);
console.log(...arr4);/*
    Some more complex uses ofã€iteratorsã€‘ï¼š
        1ï¼‰passing arguments to iterators
        2ï¼‰throwing errors in iteratorsï¼ˆ& catch themï¼‰
        3ï¼‰generator return statements
        4ï¼‰delegating generators
*/

// 1ï¼‰passing arguments to iterators
function *createIterator_1() {
    let first = yield 1;            // 1
    let second = yield first + 2;   // 4 + 2
    yield second + 3;               // 5 + 3
}
const iterator_1 = createIterator_1();
console.log(iterator_1.next());   // "{ value: 1, done: false }"
console.log(iterator_1.next(4));  // "{ value: 6, done: false }"
console.log(iterator_1.next(5));  // "{ value: 8, done: false }"
console.log(iterator_1.next());   // "{ value: undefined, done: true }

// 2ï¼‰throwing errors in iteratorsï¼ˆ& catch themï¼‰
function *createIterator_2() {
    let first = yield 1;
    let second;
    try {
        second = yield first + 2; // yield 4 + 2, then throw
    } catch (err) {
        second = 6; // on error, assign a different value
    }
    yield second + 3;
}
const iterator_2 = createIterator_2();
console.log(iterator_2.next()); // "{ value: 1, done: false }"
console.log(iterator_2.next(4)); // "{ value: 6, done: false }"
console.log(iterator_2.throw(new Error("Boom"))); // "{ value: 9, done: false }"
console.log(iterator_2.next()); // "{ value: undefined, done: true }"

// 3ï¼‰generator return statements
function *createIterator__3() {
    yield 1;
    return 2;
    yield 3;    // unreachable
}
const iterator_3 = createIterator__3();
console.log(iterator_3.next());     // "{ value: 1, done: false }"
console.log(iterator_3.next());     // "{ value: 2, done: true }"
// Theã€spread operatorã€‘andã€for-ofã€‘ignore any value specified by aã€returnã€‘statement.
// As soon as they seeã€doneã€‘isã€tureã€‘ï¼Œthey stop without reading theã€valueã€‘.
console.log(...createIterator__3());    // 1
for(let val of createIterator__3()) {   // 1
    console.log(val);
}

// 4ï¼‰delegating generators
function *createNumberIterator() {
    yield 1;
    // this return value 2 exists solely inside the "createCombinedIterator"
    // generator, and will not be output from any call to the next() method
    return 2;
}
function *createColorIterator() {
    yield "red";
    yield "green";
}
function *createCombinedIterator() {
    yield *createNumberIterator();
    yield *createColorIterator();
    yield true;
}
const iterator_4 = createCombinedIterator();
console.log(iterator_4.next()); // "{ value: 1, done: false }"
console.log(iterator_4.next()); // "{ value: "red", done: false }"
console.log(iterator_4.next()); // "{ value: "green", done: false }"
console.log(iterator_4.next()); // "{ value: true, done: false }"
console.log(iterator_4.next()); // "{ value: undefined, done: true }"

function *createNumberIterator1() {
    yield 1;
    return 2;
}
function *createRepeatingIterator1(count) {
    for (let i=0; i < count; i++) {
        yield "repeat";
    }
}
function *createCombinedIterator1() {
    let result = yield *createNumberIterator1();
    //// we can output the return value 2 by adding anotherã€yieldã€‘statement
    // yield result;
    yield *createRepeatingIterator1(result);
}
var iterator_5 = createCombinedIterator1();
console.log(iterator_5.next()); // "{ value: 1, done: false }"
// console.log(iterator_5.next()); // "{ value: 2, done: false }"
console.log(iterator_5.next()); // "{ value: "repeat", done: false }"
console.log(iterator_5.next()); // "{ value: "repeat", done: false }"
console.log(iterator_5.next()); // "{ value: undefined, done: true }"

/*
    We can useã€yield *ã€‘directly onã€iterablesã€‘
*/
const str_iter = function *() {
    yield * ['A','B'];
    yield * "CD";
    yield * new Set(['E']);
    yield * new Map([['F', 'f']]);
}();
console.log(str_iter.next()); // "{ value: 'A', done: true }"
console.log(str_iter.next()); // "{ value: 'B', done: true }"
console.log(str_iter.next()); // "{ value: 'C', done: true }"
console.log(str_iter.next()); // "{ value: 'D', done: true }"
console.log(str_iter.next()); // "{ value: 'E', done: true }"
console.log(str_iter.next()); // "{ value: ['F', 'f'], done: true }"
console.log(str_iter.next()); // "{ value: undefined, done: true }"

/*
    Asynchronous Task Running
*/
function run(taskDef) {
    // create the iterator, make available elsewhere
    let task = taskDef();
    // start the task
    let result = task.next(); // ----------ï¼ˆ1ï¼‰----------
    // recursive function to keep calling next()
    function step() {
        // if there's more to do
        if (!result.done) {
            if (typeof result.value === "function") {
                result.value(function(err, data) { // ----------ï¼ˆ2ï¼‰----------
                    if (err) {
                        result = task.throw(err);
                        return;
                    }
                    result = task.next(data);
                    step();
                });
            } else {
                result = task.next(result.value);
                step();
            }
        }
    }
    // start the process
    step();
}
function asyncFunc(param) { // ----------ï¼ˆ1ï¼‰----------
    return function(callback) { // ----------ï¼ˆ2ï¼‰----------
        setTimeout(() => {
            // callback (err, data)
            if(param=='success') {
                callback(null, param + ' and hooray!');
            }else{
                callback(new Error(param + ' and oops!'))
            }
        }, 2000);
    };  
}
run(function *() {
    const res1 = yield asyncFunc("success");
    console.log("res1:::", res1); // res1::: success and hooray!
    
    try {
        const res2 = yield asyncFunc("failure");
        console.log("res2:::", res2);
    }catch (err) {
        console.log("res2:::", err); // res2::: Error: failure and oops!
    }
});

/*
    The proxy virtualized theã€targetã€‘so theã€proxyã€‘and the target appear to be functionally the same.

    Using aã€trap], it allows you toã€interceptã€‘low-level object operations on theã€targetã€‘that are otherwiseinternal to the JS engine.

    Theã€Reflectionã€‘API provide theã€default behaviorã€‘for the same low-level operations that proxies can override.
    There is aã€Reflectã€‘method for everyã€proxy trapã€‘ï¼ˆsame names, same argumentsï¼‰.

    ã€Proxy Trapsã€‘in JS includeï¼š
    ã€Proxy Trapã€‘              ã€Overrides the built-in Behavior ofã€‘ ã€Default Behaviorã€‘
    1ï¼‰get                      read a property value                  Reflect.get()
    2ï¼‰set                      write to a property                    Reflect.set()
    3ï¼‰has                      theã€inã€‘operator                       Reflect.has()
    4ï¼‰deleteProperty           theã€deleteã€‘operator                   Reflect.deleteProperty()
    5ï¼‰getPrototypeOf           Object.getPrototypeOf()                Reflect.getPrototypeOf()
    6ï¼‰setPrototypeOf           Object.setPrototypeOf()                Reflect.setPrototypeOf()
    7ï¼‰isExtensible             Object.isExtensible()                  Reflect.isExtensible()
    8ï¼‰preventExtensions        Object.preventExtensions()             Reflect.preventExtensions()
    9ï¼‰getOwnPropertyDescriptor Object.getOwnPropertyDescriptor()      Reflect.getOwnPropertyDescriptor()
    10ï¼‰defineProperty          Object.defineProperty()                Reflect.defineProperty()
    11ï¼‰ownKeys                 Object.keys()                          Reflect.ownKeys()
                                Object.getOwnPropertyNames()
                                Object.getOwnPropertySymbols()
    12ï¼‰apply                   calling a function                     Reflect.apply()
    13ï¼‰construct               calling a function with new            Reflect.construct()
*/

// Create a simple proxyï¼šproxy(target, handler)
const target = {};
// Default behaviors are used for operations of which no trap is defined in the handler.
const proxy = new Proxy(target, {}); // a pass-through proxy
// The proxy is NOT storing the property, but simply forwarding the operation.
proxy.name = 'XTina';
console.log("Name:::", proxy.name, target.name);    // XTina XTina
target.name = 'Airboy';
console.log("Name:::", proxy.name, target.name);    // Airboy Airboy

// Proxies help avoid acessing non-existent properties by havingã€object shape validationã€‘.
const proxy_1 = new Proxy(target, {
    set(trapTarget, key, value, receiver) {
        console.log("set:::", trapTarget, key, value, receiver);
        return Reflect.set(trapTarget, key, value, receiver);
    },
    get(trapTarget, key, receiver) {
        console.log("get:::", trapTarget, key, receiver);
        return Reflect.get(trapTarget, key, receiver);
    },
    has(trapTarget, key) {
        console.log("has:::", trapTarget, key);
        return Reflect.has(trapTarget, key);
    }
})

// Who can emerge out of a trade war safe & soundï¼Ÿ
</script>